<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Device Position Tracker</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a1a;
      color: #fff;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    
    header {
      background: #2a2a2a;
      padding: 1rem 2rem;
      border-bottom: 2px solid #3a3a3a;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    h1 {
      font-size: 1.5rem;
      font-weight: 600;
    }
    
    .status {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.5rem;
      background: #666;
    }
    
    .status.connected {
      background: #4ade80;
    }

    .nav-link {
      color: #60a5fa;
      text-decoration: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .nav-link:hover {
      background: #3a3a3a;
    }
    
    main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    
    #canvas-container {
      flex: 1;
      position: relative;
      background: #0a0a0a;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    
    aside {
      width: 300px;
      background: #2a2a2a;
      border-left: 2px solid #3a3a3a;
      padding: 1.5rem;
      overflow-y: auto;
    }
    
    h2 {
      font-size: 1.1rem;
      margin-bottom: 1rem;
      color: #999;
      text-transform: uppercase;
      font-weight: 500;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
    }
    
    .device-list, .sensor-list {
      margin-bottom: 2rem;
    }
    
    .device-item, .sensor-item {
      background: #1a1a1a;
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      border-radius: 6px;
      font-size: 0.9rem;
    }
    
    .device-id, .sensor-id {
      font-weight: 600;
      color: #4ade80;
      margin-bottom: 0.25rem;
    }
    
    .sensor-id {
      color: #60a5fa;
    }

    .sensor-id.overridden {
      color: #fbbf24;
    }
    
    .coords {
      color: #999;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 0.85rem;
    }

    .coord-input {
      background: #0a0a0a;
      border: 1px solid #3a3a3a;
      color: #fff;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      width: 60px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 0.85rem;
      margin: 0 0.25rem;
    }

    .coord-input:focus {
      outline: none;
      border-color: #60a5fa;
    }

    .sensor-controls {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .btn {
      background: #3a3a3a;
      border: none;
      color: #fff;
      padding: 0.35rem 0.75rem;
      border-radius: 4px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn:hover {
      background: #4a4a4a;
    }

    .btn-primary {
      background: #60a5fa;
    }

    .btn-primary:hover {
      background: #3b82f6;
    }

    .btn-danger {
      background: #ef4444;
    }

    .btn-danger:hover {
      background: #dc2626;
    }

    .override-badge {
      display: inline-block;
      background: #fbbf24;
      color: #1a1a1a;
      padding: 0.1rem 0.4rem;
      border-radius: 3px;
      font-size: 0.7rem;
      font-weight: 600;
      margin-left: 0.5rem;
    }

    .pause-btn {
      background: #3a3a3a;
      border: none;
      color: #fff;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
      transition: background 0.2s;
      margin-right: 1rem;
    }

    .pause-btn:hover {
      background: #4a4a4a;
    }

    .pause-btn.paused {
      background: #fbbf24;
      color: #1a1a1a;
    }
    
    .legend {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
      padding-top: 1rem;
      border-top: 1px solid #3a3a3a;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      color: #999;
    }
    
    .legend-icon {
      width: 16px;
      height: 16px;
    }
  </style>
</head>
<body>
  <header>
    <h1><span class="status" id="status"></span>Device Position Tracker</h1>
    <div>
      <button id="pause-btn" class="pause-btn" title="Pause updates">⏸</button>
      <a href="/readings" class="nav-link">View Readings</a>
    </div>
  </header>
  
  <main>
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
    
    <aside>
      <div class="device-list">
        <h2>Devices</h2>
        <div id="devices"></div>
      </div>
      
      <div class="sensor-list">
        <h2>ESP32 Sensors</h2>
        <div id="sensors"></div>
      </div>
      
      <div class="legend">
        <div class="legend-item">
          <svg class="legend-icon" viewBox="0 0 16 16">
            <circle cx="8" cy="8" r="6" fill="#4ade80" />
          </svg>
          <span>Device</span>
        </div>
        <div class="legend-item">
          <svg class="legend-icon" viewBox="0 0 16 16">
            <polygon points="8,2 14,14 2,14" fill="#60a5fa" />
          </svg>
          <span>Sensor</span>
        </div>
        <div class="legend-item">
          <svg class="legend-icon" viewBox="0 0 16 16">
            <polygon points="8,2 14,14 2,14" fill="#fbbf24" />
          </svg>
          <span>Override</span>
        </div>
      </div>
    </aside>
  </main>
  
  <script>
    const canvas = document.getElementById('canvas')
    const ctx = canvas.getContext('2d')
    const statusIndicator = document.getElementById('status')
    const devicesContainer = document.getElementById('devices')
    const sensorsContainer = document.getElementById('sensors')
    
    let devices = []
    let sensors = []
    
    const PADDING = 60
    const GRID_SIZE = 50
    
    function resizeCanvas() {
      const container = canvas.parentElement
      canvas.width = container.clientWidth
      canvas.height = container.clientHeight
      draw()
    }
    
    window.addEventListener('resize', resizeCanvas)
    resizeCanvas()
    
    function worldToScreen(x, y) {
      const bounds = getWorldBounds()
      const worldWidth = bounds.maxX - bounds.minX
      const worldHeight = bounds.maxY - bounds.minY
      
      const canvasWidth = canvas.width - 2 * PADDING
      const canvasHeight = canvas.height - 2 * PADDING
      
      const scaleX = worldWidth > 0 ? canvasWidth / worldWidth : 1
      const scaleY = worldHeight > 0 ? canvasHeight / worldHeight : 1
      const scale = Math.min(scaleX, scaleY, 50)
      
      const screenX = PADDING + (x - bounds.minX) * scale + (canvasWidth - worldWidth * scale) / 2
      const screenY = PADDING + (y - bounds.minY) * scale + (canvasHeight - worldHeight * scale) / 2
      
      return { x: screenX, y: screenY, scale }
    }
    
    function getWorldBounds() {
      const allPoints = [
        ...devices.map(d => ({ x: d.x, y: d.y })),
        ...sensors.map(s => ({ x: s.x, y: s.y }))
      ]
      
      if (allPoints.length === 0) {
        return { minX: -5, maxX: 5, minY: -5, maxY: 5 }
      }
      
      const minX = Math.min(...allPoints.map(p => p.x))
      const maxX = Math.max(...allPoints.map(p => p.x))
      const minY = Math.min(...allPoints.map(p => p.y))
      const maxY = Math.max(...allPoints.map(p => p.y))
      
      const marginX = (maxX - minX) * 0.2 || 2
      const marginY = (maxY - minY) * 0.2 || 2
      
      return {
        minX: minX - marginX,
        maxX: maxX + marginX,
        minY: minY - marginY,
        maxY: maxY + marginY
      }
    }
    
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      
      drawGrid()
      drawSensors()
      drawDevices()
    }
    
    function drawGrid() {
      const bounds = getWorldBounds()
      ctx.strokeStyle = '#2a2a2a'
      ctx.lineWidth = 1
      
      for (let x = Math.floor(bounds.minX); x <= Math.ceil(bounds.maxX); x += 1) {
        const screen = worldToScreen(x, 0)
        ctx.beginPath()
        ctx.moveTo(screen.x, PADDING)
        ctx.lineTo(screen.x, canvas.height - PADDING)
        ctx.stroke()
        
        ctx.fillStyle = '#666'
        ctx.font = '10px monospace'
        ctx.textAlign = 'center'
        ctx.fillText(x.toString(), screen.x, canvas.height - PADDING + 15)
      }
      
      for (let y = Math.floor(bounds.minY); y <= Math.ceil(bounds.maxY); y += 1) {
        const screen = worldToScreen(0, y)
        ctx.beginPath()
        ctx.moveTo(PADDING, screen.y)
        ctx.lineTo(canvas.width - PADDING, screen.y)
        ctx.stroke()
        
        ctx.fillStyle = '#666'
        ctx.font = '10px monospace'
        ctx.textAlign = 'right'
        ctx.fillText(y.toString(), PADDING - 10, screen.y + 4)
      }
    }
    
    function drawSensors() {
      sensors.forEach(sensor => {
        const pos = worldToScreen(sensor.x, sensor.y)
        
        const color = sensor.isOverridden ? '#fbbf24' : '#60a5fa'
        ctx.fillStyle = color
        ctx.beginPath()
        ctx.moveTo(pos.x, pos.y - 10)
        ctx.lineTo(pos.x + 9, pos.y + 8)
        ctx.lineTo(pos.x - 9, pos.y + 8)
        ctx.closePath()
        ctx.fill()
        
        ctx.fillStyle = color
        ctx.font = '11px sans-serif'
        ctx.textAlign = 'center'
        ctx.fillText(sensor.id, pos.x, pos.y + 25)
      })
    }
    
    function drawDevices() {
      devices.forEach(device => {
        const pos = worldToScreen(device.x, device.y)
        
        ctx.fillStyle = '#4ade80'
        ctx.beginPath()
        ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2)
        ctx.fill()
        
        ctx.strokeStyle = '#1a1a1a'
        ctx.lineWidth = 2
        ctx.stroke()
        
        ctx.fillStyle = '#4ade80'
        ctx.font = '11px sans-serif'
        ctx.textAlign = 'center'
        ctx.fillText(device.id.substring(0, 8), pos.x, pos.y - 15)
      })
    }
    
    function formatTimestamp(timestamp) {
      const now = Date.now()
      const diff = now - timestamp
      
      if (diff < 1000) return 'just now'
      if (diff < 60000) return `${Math.floor(diff / 1000)}s ago`
      if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`
      return new Date(timestamp).toLocaleTimeString()
    }
    
    function updateDevicesList() {
      devicesContainer.innerHTML = devices.length === 0 
        ? '<div style="color: #666; font-size: 0.9rem;">No devices detected</div>'
        : devices.map(device => `
          <div class="device-item">
            <div class="device-id">${device.id}</div>
            <div class="coords">x: ${device.x.toFixed(2)}, y: ${device.y.toFixed(2)}</div>
            <div class="coords" style="margin-top: 0.25rem;">${formatTimestamp(device.timestamp)}</div>
          </div>
        `).join('')
    }
    
    function updateSensorsList() {
      sensorsContainer.innerHTML = sensors.length === 0
        ? '<div style="color: #666; font-size: 0.9rem;">No sensors active</div>'
        : sensors.map(sensor => `
          <div class="sensor-item" data-sensor-id="${sensor.id}">
            <div class="sensor-id ${sensor.isOverridden ? 'overridden' : ''}">
              ${sensor.id}
              ${sensor.isOverridden ? '<span class="override-badge">OVERRIDE</span>' : ''}
            </div>
            <div class="coords">
              x: <input type="number" step="0.1" class="coord-input" data-coord="x" value="${sensor.x.toFixed(2)}" />
              y: <input type="number" step="0.1" class="coord-input" data-coord="y" value="${sensor.y.toFixed(2)}" />
            </div>
            <div class="sensor-controls">
              <button class="btn btn-primary btn-save">Save</button>
              ${sensor.isOverridden ? '<button class="btn btn-danger btn-reset">Reset</button>' : ''}
            </div>
          </div>
        `).join('')
      
      document.querySelectorAll('.sensor-item').forEach((item, index) => {
        const sensor = sensors[index]
        const saveBtn = item.querySelector('.btn-save')
        const resetBtn = item.querySelector('.btn-reset')
        
        if (saveBtn) {
          saveBtn.addEventListener('click', () => saveSensorPosition(sensor))
        }
        
        if (resetBtn) {
          resetBtn.addEventListener('click', () => resetSensorPosition(sensor))
        }
      })
    }
    
    function updateSidebar() {
      updateDevicesList()
      updateSensorsList()
    }

    async function saveSensorPosition(sensor) {
      const sensorItem = document.querySelector(`[data-sensor-id="${sensor.id}"]`)
      const xInput = sensorItem.querySelector('[data-coord="x"]')
      const yInput = sensorItem.querySelector('[data-coord="y"]')
      
      const x = parseFloat(xInput.value)
      const y = parseFloat(yInput.value)
      
      if (isNaN(x) || isNaN(y)) {
        alert('Invalid coordinates')
        return
      }
      
      try {
        const response = await fetch('/api/sensors', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ sensorId: sensor.id, x, y })
        })
        
        if (!response.ok) {
          throw new Error('Failed to update sensor position')
        }
        
        console.log('Sensor position updated:', sensor.id)
      } catch (err) {
        console.error('Error updating sensor:', err)
        alert('Failed to update sensor position')
      }
    }

    async function resetSensorPosition(sensor) {
      try {
        const response = await fetch(`/api/sensors/${encodeURIComponent(sensor.id)}`, {
          method: 'DELETE'
        })
        
        if (!response.ok) {
          throw new Error('Failed to reset sensor position')
        }
        
        console.log('Sensor position reset:', sensor.id)
      } catch (err) {
        console.error('Error resetting sensor:', err)
        alert('Failed to reset sensor position')
      }
    }
    
    let previousSensors = []
    
    function sensorsChanged(newSensors) {
      if (previousSensors.length !== newSensors.length) return true
      
      for (let i = 0; i < newSensors.length; i++) {
        const prev = previousSensors[i]
        const curr = newSensors[i]
        
        if (prev.id !== curr.id || 
            prev.x !== curr.x || 
            prev.y !== curr.y || 
            prev.isOverridden !== curr.isOverridden) {
          return true
        }
      }
      
      return false
    }
    
    function saveFocusState() {
      const active = document.activeElement
      if (active && active.classList.contains('coord-input')) {
        const sensorItem = active.closest('.sensor-item')
        if (sensorItem) {
          return {
            sensorId: sensorItem.dataset.sensorId,
            coord: active.dataset.coord,
            value: active.value,
            selectionStart: active.selectionStart,
            selectionEnd: active.selectionEnd
          }
        }
      }
      return null
    }
    
    function restoreFocusState(focusState) {
      if (!focusState) return
      
      const sensorItem = document.querySelector(`[data-sensor-id="${focusState.sensorId}"]`)
      if (!sensorItem) return
      
      const input = sensorItem.querySelector(`[data-coord="${focusState.coord}"]`)
      if (input) {
        input.value = focusState.value
        input.focus()
        input.setSelectionRange(focusState.selectionStart, focusState.selectionEnd)
      }
    }
    
    let isPaused = false
    
    const pauseBtn = document.getElementById('pause-btn')
    pauseBtn.addEventListener('click', () => {
      isPaused = !isPaused
      pauseBtn.textContent = isPaused ? '▶' : '⏸'
      pauseBtn.classList.toggle('paused')
      pauseBtn.title = isPaused ? 'Resume updates' : 'Pause updates'
    })
    
    const ws = new WebSocket(`ws://${window.location.host}`)
    
    ws.onopen = () => {
      console.log('WebSocket connected')
      statusIndicator.classList.add('connected')
    }
    
    ws.onclose = () => {
      console.log('WebSocket disconnected')
      statusIndicator.classList.remove('connected')
    }
    
    ws.onmessage = (event) => {
      if (isPaused) return
      
      try {
        const data = JSON.parse(event.data)
        devices = data.devices || []
        
        const newSensors = data.sensors || []
        const sensorDataChanged = sensorsChanged(newSensors)
        
        draw()
        
        if (sensorDataChanged) {
          const focusState = saveFocusState()
          sensors = newSensors
          previousSensors = JSON.parse(JSON.stringify(newSensors))
          updateSidebar()
          restoreFocusState(focusState)
        } else {
          sensors = newSensors
          updateDevicesList()
        }
      } catch (err) {
        console.error('Error parsing message:', err)
      }
    }
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error)
    }
  </script>
</body>
</html>
